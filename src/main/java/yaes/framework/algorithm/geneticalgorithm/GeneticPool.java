/* * Created on Oct 12, 2004 * * TODO To change the template for this generated file go to * Window - Preferences - Java - Code Style - Code Templates */package yaes.framework.algorithm.geneticalgorithm;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Set;/** * @author Lotzi Boloni *  *         TODO To change the template for this generated type comment go to *         Window - Preferences - Java - Code Style - Code Templates */public class GeneticPool {    private List<IChromosome>       chromosomes;    private ICrossover              crossover;    private double                  crossoverRate     = 0.5;    private final IFittnessFunction fittnessFunction;    private boolean                 keepUnmutated     = false;    private IMutation               mutation;    private double                  mutationRate      = 0.5;    private final ISelectionMethod  selectionMethod;    private boolean                 useMultiCrossover = false;    /**     * @param fittnessFunction     * @param crossover     * @param mutation     */    public GeneticPool(IFittnessFunction fittnessFunction,            ISelectionMethod selectionMethod, ICrossover crossover,            IMutation mutation) {        super();        this.fittnessFunction = fittnessFunction;        this.crossover = crossover;        this.mutation = mutation;        this.selectionMethod = selectionMethod;        chromosomes = new ArrayList<>();    }    public void compete() {        final int n = chromosomes.size();        final int mutations = (int) (n * mutationRate);        final int crossovers = (int) (n * crossoverRate);        // Select and save Elitist        final List<IChromosome> elitist = chromosomes.subList(0, 1);        // Select survivors        final ArrayList<IChromosome> newGeneration = new ArrayList<>();        final int survivorCount = n - crossovers;        for (int i = 0; i < survivorCount; i++) {            newGeneration.add(selectionMethod.SelectChromosomes(chromosomes));        }        // Apply Crossover Operator (Select by using selection method)        int count = 0;        while (count < crossovers) {            // Select a two parents            final IChromosome chrom1 = selectionMethod                    .SelectChromosomes(chromosomes);            final IChromosome chrom2 = selectionMethod                    .SelectChromosomes(chromosomes);            // Select until one finds some which can mate...            if (!crossover.canMate(chrom1, chrom2)) {                continue;            }            // Perform multi crossover (more than one child is created)            if (useMultiCrossover) {                final Set<IChromosome> children = crossover.multipleCrossover(                        chrom1, chrom2);                newGeneration.addAll(children);                count += children.size();            } else// Perform single crossover (one child is generated)            {                final IChromosome newChrom = crossover.singleCrossover(chrom1,                        chrom2);                newGeneration.add(newChrom);                count++;            }        }        // Apply Mutation Operator (Select with uniform probability)        for (int i = 0; i != mutations; i++) {            final IChromosome chrom1 = getRandomChromosome(newGeneration);            final IChromosome newChrom = mutation.mutate(chrom1);            if (!keepUnmutated) {                newGeneration.remove(chrom1);            }            newGeneration.add(newChrom);        }        // Update the population to the newly created chromosomes        chromosomes = newGeneration;        // Append the elitist chromosomes        chromosomes.addAll(elitist);        // Calculate fitness and sort the chromosomes by fitness (lowest fitness        // first in list)        final FittnessFunctionComparator comp = new FittnessFunctionComparator(                fittnessFunction);        Collections.sort(chromosomes, comp);        // Get rid of extra chromosomes created        chromosomes = chromosomes.subList(0, n);    }    /**     * @return Returns the chromosomes.     */    public List<IChromosome> getChromosomes() {        return chromosomes;    }    /**     * @return Returns the crossover.     */    public ICrossover getCrossover() {        return crossover;    }    /**     * @return Returns the crossoverRate.     */    public double getCrossoverRate() {        return crossoverRate;    }    /**     * @return Returns the fittnessFunction.     */    public IFittnessFunction getFittnessFunction() {        return fittnessFunction;    }    /**     * @return Returns the mutation.     */    public IMutation getMutation() {        return mutation;    }    /**     * @return Returns the mutationRate.     */    public double getMutationRate() {        return mutationRate;    }    /**     * @return     */    private IChromosome getRandomChromosome(            List<IChromosome> chromosomeGeneration) {        final int n = chromosomeGeneration.size();        final int selected = (int) (Math.random() * n);        return chromosomeGeneration.get(selected);    }    /**     * @return Returns the selectionMethod.     */    public ISelectionMethod getSelectionMethod() {        return selectionMethod;    }    /**     * @return Returns the keepUnmutated.     */    public boolean isKeepUnmutated() {        return keepUnmutated;    }    /**     * @return Returns the useMultiCrossover.     */    public boolean isUseMultiCrossover() {        return useMultiCrossover;    }    /**     * @param crossover     *            The crossover to set.     */    public void setCrossover(ICrossover crossover) {        this.crossover = crossover;    }    /**     * @param crossoverRate     *            The crossoverRate to set.     */    public void setCrossoverRate(double crossoverRate) {        this.crossoverRate = crossoverRate;    }    /**     * @param keepUnmutated     *            The keepUnmutated to set.     */    public void setKeepUnmutated(boolean keepUnmutated) {        this.keepUnmutated = keepUnmutated;    }    /**     * @param mutation     *            The mutation to set.     */    public void setMutation(IMutation mutation) {        this.mutation = mutation;    }    /**     * @param mutationRate     *            The mutationRate to set.     */    public void setMutationRate(double mutationRate) {        this.mutationRate = mutationRate;    }    /**     * @param useMultiCrossover     *            The useMultiCrossover to set.     */    public void setUseMultiCrossover(boolean useMultiCrossover) {        this.useMultiCrossover = useMultiCrossover;    }}